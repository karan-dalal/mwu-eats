{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport fetch from 'cross-fetch';\nexport class PostgrestBuilder {\n  constructor(builder) {\n    this.shouldThrowOnError = false;\n    Object.assign(this, builder);\n  }\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n\n\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n\n  then(onfulfilled, onrejected) {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (typeof this.schema === 'undefined') {// skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema;\n    } else {\n      this.headers['Content-Profile'] = this.schema;\n    }\n\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json';\n    }\n\n    let res = fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal\n    }).then(res => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n\n      let error = null;\n      let data = null;\n      let count = null;\n\n      if (res.ok) {\n        const isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');\n\n        if (this.method !== 'HEAD' && !isReturnMinimal) {\n          const text = yield res.text();\n\n          if (!text) {// discard `text`\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = text;\n          } else {\n            data = JSON.parse(text);\n          }\n        }\n\n        const countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n        const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1]);\n        }\n      } else {\n        error = yield res.json();\n\n        if (error && this.shouldThrowOnError) {\n          throw error;\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status: res.status,\n        statusText: res.statusText,\n        body: data\n      };\n      return postgrestResponse;\n    }));\n\n    if (!this.shouldThrowOnError) {\n      res = res.catch(fetchError => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: '',\n          hint: '',\n          code: fetchError.code || ''\n        },\n        data: null,\n        body: null,\n        count: null,\n        status: 400,\n        statusText: 'Bad Request'\n      }));\n    }\n\n    return res.then(onfulfilled, onrejected);\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport fetch from 'cross-fetch';\nexport class PostgrestBuilder {\n    constructor(builder) {\n        this.shouldThrowOnError = false;\n        Object.assign(this, builder);\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */\n    throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (typeof this.schema === 'undefined') {\n            // skip\n        }\n        else if (['GET', 'HEAD'].includes(this.method)) {\n            this.headers['Accept-Profile'] = this.schema;\n        }\n        else {\n            this.headers['Content-Profile'] = this.schema;\n        }\n        if (this.method !== 'GET' && this.method !== 'HEAD') {\n            this.headers['Content-Type'] = 'application/json';\n        }\n        let res = fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal,\n        }).then((res) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            let error = null;\n            let data = null;\n            let count = null;\n            if (res.ok) {\n                const isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');\n                if (this.method !== 'HEAD' && !isReturnMinimal) {\n                    const text = yield res.text();\n                    if (!text) {\n                        // discard `text`\n                    }\n                    else if (this.headers['Accept'] === 'text/csv') {\n                        data = text;\n                    }\n                    else {\n                        data = JSON.parse(text);\n                    }\n                }\n                const countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n                if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                }\n            }\n            else {\n                error = yield res.json();\n                if (error && this.shouldThrowOnError) {\n                    throw error;\n                }\n            }\n            const postgrestResponse = {\n                error,\n                data,\n                count,\n                status: res.status,\n                statusText: res.statusText,\n                body: data,\n            };\n            return postgrestResponse;\n        }));\n        if (!this.shouldThrowOnError) {\n            res = res.catch((fetchError) => ({\n                error: {\n                    message: `FetchError: ${fetchError.message}`,\n                    details: '',\n                    hint: '',\n                    code: fetchError.code || '',\n                },\n                data: null,\n                body: null,\n                count: null,\n                status: 400,\n                statusText: 'Bad Request',\n            }));\n        }\n        return res.then(onfulfilled, onrejected);\n    }\n}\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"module"}