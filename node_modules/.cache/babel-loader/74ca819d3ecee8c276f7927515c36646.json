{"ast":null,"code":"import { PostgrestBuilder } from './types';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder extends PostgrestBuilder {\n  constructor(url, {\n    headers = {},\n    schema\n  } = {}) {\n    super({});\n    this.url = new URL(url);\n    this.headers = Object.assign({}, headers);\n    this.schema = schema;\n  }\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   * @param head  When set to true, select will void data.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n\n\n  select(columns = '*', {\n    head = false,\n    count = null\n  } = {}) {\n    this.method = 'GET'; // Remove whitespaces except when quoted\n\n    let quoted = false;\n    const cleanedColumns = columns.split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`;\n    }\n\n    if (head) {\n      this.method = 'HEAD';\n    }\n\n    return new PostgrestFilterBuilder(this);\n  }\n\n  insert(values, {\n    upsert = false,\n    onConflict,\n    returning = 'representation',\n    count = null\n  } = {}) {\n    this.method = 'POST';\n    const prefersHeaders = [`return=${returning}`];\n    if (upsert) prefersHeaders.push('resolution=merge-duplicates');\n    if (upsert && onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n    this.body = values;\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n\n    return new PostgrestFilterBuilder(this);\n  }\n  /**\n   * Performs an UPSERT into the table.\n   *\n   * @param values  The values to insert.\n   * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n   */\n\n\n  upsert(values, {\n    onConflict,\n    returning = 'representation',\n    count = null,\n    ignoreDuplicates = false\n  } = {}) {\n    this.method = 'POST';\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`, `return=${returning}`];\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n    this.body = values;\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder(this);\n  }\n  /**\n   * Performs an UPDATE on the table.\n   *\n   * @param values  The values to update.\n   * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n\n\n  update(values, {\n    returning = 'representation',\n    count = null\n  } = {}) {\n    this.method = 'PATCH';\n    const prefersHeaders = [`return=${returning}`];\n    this.body = values;\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder(this);\n  }\n  /**\n   * Performs a DELETE on the table.\n   *\n   * @param returning  If `true`, return the deleted row(s) in the response.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n\n\n  delete({\n    returning = 'representation',\n    count = null\n  } = {}) {\n    this.method = 'DELETE';\n    const prefersHeaders = [`return=${returning}`];\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder(this);\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/PostgrestQueryBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { PostgrestBuilder } from './types';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder extends PostgrestBuilder {\n    constructor(url, { headers = {}, schema } = {}) {\n        super({});\n        this.url = new URL(url);\n        this.headers = Object.assign({}, headers);\n        this.schema = schema;\n    }\n    /**\n     * Performs vertical filtering with SELECT.\n     *\n     * @param columns  The columns to retrieve, separated by commas.\n     * @param head  When set to true, select will void data.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    select(columns = '*', { head = false, count = null, } = {}) {\n        this.method = 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = columns\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers['Prefer'] = `count=${count}`;\n        }\n        if (head) {\n            this.method = 'HEAD';\n        }\n        return new PostgrestFilterBuilder(this);\n    }\n    insert(values, { upsert = false, onConflict, returning = 'representation', count = null, } = {}) {\n        this.method = 'POST';\n        const prefersHeaders = [`return=${returning}`];\n        if (upsert)\n            prefersHeaders.push('resolution=merge-duplicates');\n        if (upsert && onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        this.body = values;\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs an UPSERT into the table.\n     *\n     * @param values  The values to insert.\n     * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n     * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n     */\n    upsert(values, { onConflict, returning = 'representation', count = null, ignoreDuplicates = false, } = {}) {\n        this.method = 'POST';\n        const prefersHeaders = [\n            `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,\n            `return=${returning}`,\n        ];\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        this.body = values;\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs an UPDATE on the table.\n     *\n     * @param values  The values to update.\n     * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    update(values, { returning = 'representation', count = null, } = {}) {\n        this.method = 'PATCH';\n        const prefersHeaders = [`return=${returning}`];\n        this.body = values;\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs a DELETE on the table.\n     *\n     * @param returning  If `true`, return the deleted row(s) in the response.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    delete({ returning = 'representation', count = null, } = {}) {\n        this.method = 'DELETE';\n        const prefersHeaders = [`return=${returning}`];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder(this);\n    }\n}\n//# sourceMappingURL=PostgrestQueryBuilder.js.map"]},"metadata":{},"sourceType":"module"}